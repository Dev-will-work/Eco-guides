#Включение:

<имя> - имя вашего проекта(точки в имени не считаются)

##C<имя>.h:

добавить в начало структуры:
  >  /* Таблица функций интерфейса IEcoCalculatorX \*/
  >  IEcoCalculatorX m_VtblIX;
  >  /* Указатель на интерфейс IEcoCalculatorX включаемого компонента \*/
  >  IEcoCalculatorX* m_pIX;


##C<имя>.c:

**функция QueryInterface:**

- Название должно быть `C<имя>_I<имя>_QueryInterface`
- заменить первую строку с `pCMe` на 
`C<имя>* pCMe = (C<имя>*)((uint64_t)me - sizeof(struct IEcoCalculatorX));`

- Добавить эти строки перед цепочкой условий:
  >  /* Проверка и получение запрошенного интерфейса \*/
  >  if ( IsEqualUGUID(riid, &IID_IEcoCalculatorX) ) {
  >      *ppv = &pCMe->m_VtblIX;
  >      pCMe->m_VtblIX.AddRef(&pCMe->m_VtblIX);
  >  }
  >  else

**функция AddRef:**
- Название должно быть `C<имя>_I<имя>_AddRef`
- заменить первую строку с `pCMe` на 
`C<имя>* pCMe = (C<имя>*)((uint64_t)me - sizeof(struct IEcoCalculatorX));`

**функция Release:**
- Название должно быть `C<имя>_I<имя>_Release`
- заменить первую строку с `pCMe` на 
`C<имя>* pCMe = (C<имя>*)((uint64_t)me - sizeof(struct IEcoCalculatorX));`

**функция initC<имя>:**
- первый аргумент - struct IEcoCalculatorX* me
- добавить строку в начале функции IEcoInterfaceBus1* pIBus = 0; 

- добавить этот код после сохранения указателя на системный интерфейс и перед return:
  >  /* Получение интерфейса для работы с интерфейсной шиной \*/
  >  result = pCMe->m_pISys->QueryInterface(pCMe->m_pISys, &IID_IEcoInterfaceBus1, (void \*\*)&pIBus);
  >  /* Получение интерфейса по работе со сложением и вычитанием у компонента "B" c поддержкой агрегирования \*/
  >  /* ВАЖНО: Компонент "B" поддерживает агрегирование, но в данном кокретном случае он не агрегируется, а включается \*/
  >  result = pIBus->QueryComponent(pIBus, &CID_EcoCalculatorB, 0, &IID_IEcoCalculatorX, (void\*\*) &pCMe->m_pIX);
  >  /* Проверка \*/
  >  if (result != 0 || pCMe->m_pIX == 0) {
  >      /* Получение интерфейса по работе со сложением и вычитанием у компонента "A" \*/
  >      result = pIBus->QueryComponent(pIBus, &CID_EcoCalculatorA, 0, &IID_IEcoCalculatorX, (void\*\*) &pCMe->m_pIX);
  >  }
  >
  >  /* Освобождение \*/
  >  pIBus->Release(pIBus);

**функция createC<имя>:**
- изменить третий аргумент функции на `IEcoCalculatorX** ppI<имя>`

- находим /* Создание таблицы функций интерфейса I<имя> \*/ 
и добавляем перед этой строкой такой блок:
  >  /* Создание таблицы функций интерфейса IEcoCalculatorX \*/
  >  pCMe->m_VtblIX.QueryInterface = IEcoCalculatorX_QueryInterface;
  >  pCMe->m_VtblIX.AddRef = CMyComponent_AddRef;
  >  pCMe->m_VtblIX.Release = CMyComponent_Release;
  >  pCMe->m_VtblIX.Addition = CMyComponent_Addition;
  >  pCMe->m_VtblIX.Subtraction = CMyComponent_Subtraction;

- потом в блоке с кучей присваиваний после найденной строки меняем Query Interface, AddRef и Release на наши, вот так:
  >  pCMe->m_VtblI<имя>.QueryInterface = C<имя>_I<имя>_QueryInterface;
  >  pCMe->m_VtblI<имя>.AddRef = C<имя>_I<имя>_AddRef;
  >  pCMe->m_VtblI<имя>.Release = C<имя>_I<имя>_Release;

- Находим /* Возврат указателя на интерфейс \*/
И меняем следующую строку на `*ppIMyComponent = &pCMe->m_VtblIX;`

**функция deleteC<имя>:**
- первый аргумент функции изменить на `IEcoCalculatorX* pIMyComponent`